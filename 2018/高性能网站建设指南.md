# 高性能网站建设指南

## 前端性能的重要性
性能的黄金法则：只有20%的最终用户响应时间花在了下载HTML文档上，其余的80%-90%的时间花在了下载页面中的所有组件上。

## 规则1：减少HTTP的请求
### 图片地图
使用图片地图和减少请求图片的http的请求数量。  
```
<img usemap="#map" src="./images/demo.png">
<map name="map">
  <area shape="rect" coords="0,0,100,100" href="1.html"></area>
  <area shape="rect" coords="100,0,200,100" href="2.html"></area>
</map>
```

### CSS Sprites
将多张图片合并为一张图片，每张子图片在这个图片上都有一个坐标，通过控制background-position的值来控制显示哪张子图片。

### 内联图片
base64编码会增加图片的大小，浏览器可能存在内联数据大小上的限制，整体的下载量会增加，但是会减少http请求的数量。内联的图片不能被缓存，但是将内联数据放到css中，也可以达到缓存的目的。  
格式：  
data:[mediatype][;base64],<data>

### 合并脚本和样式表
将脚本合并为一个文件；将样式合并为一个文件。

## 规则2：使用内容分发网络
### 使用内容分发网络
内容分发网络(CDN)是一组分布在多个不同地理位置的web服务器，用于提供静态资源服务，能够更加有效地向用户分发内容。

## 规则3：添加Expires头
### Expires头
用于确定文件什么时候失效，但是存在服务器端和客户端时间不一致的问题。

### max-age
Cache-control: max-age=36000用于设置文件在多长时间之后失效。  
如果Expires和Cache-control:max-age同时出现，max-age指令将重写Expires头。

### 修改文件名
当需要使文件失效时，修改文件名称可以迫使客户端从服务器端重新获取新的文件。

如果一个组件没有长久的Expires头，浏览器仍然会缓存这个文件，在后续的请求中，浏览器发现这个文件已经过期，为了提高效率，浏览器会发送一个条件GET请求，如果文件没有更新，服务器会返回一个消息头告诉浏览器可以使用缓存，而避免发送整个文件。和条件Get请求相关的头信息：  
```
请求头：IfModified-Since和If-None-Match
响应头：Last-Modified和ETag

在请求中会传递一个描述资源版本的值，这些值称为"验证器"，并且分为两大类：
1.文件的最后修改时间，即last-modified时间
2.一个字符串，唯一指代一个版本，称为"实体标签"，即etag
验证类型分为强验证类型和弱验证类型

条件首部：
If-Match: 如果远端实体标签与ETage中的值相同，匹配成功
If-None-Match：如果远端实体标签与ETage中的值不相同，匹配成功
If-Modified-Since：如果远端资源Last-Modified首部标记的日期比该首部中列的值要晚，匹配成功
If-Unmodified-Since：如果远端资源Last-Modified首部标记的日期比该首部中列的值要早或者相等，匹配成功
If-Range：与If-Match或If-Unmodified-Since，但是只能包含有一个实体标签或者日期值。
```  

## 规则4：压缩组件
### 压缩是如何工作的
Web客户端可以通过Http请求头中的Accept-Encoding头来表示对压缩的支持。  
```
Accept-Encoding: gzip,deflate
```  
Web服务器端通过Content-Encoding来通知客户端使用的是那种压缩。  
```
Content-Encoding: gzip
```  

gzip是目前最流行和最有效的压缩方法，另一种压缩方式deflate的效果略逊并且不太流行。  

### 压缩什么
图片和pdf不应该进行压缩，因为它们已经被压缩了，再次进行压缩只会浪费cpu的资源，并且可能会增加文件的大小。其他文件(html、css、js、json、xml等)都可以进行压缩。  

压缩的成本：服务器花费额外的cpu时间进行压缩；客户端要对压缩的文件进行解压缩。收益的大小受到多种因素的影响，例如响应的大小、连接的带宽、客户端和服务器端的距离等。根据经验，通常对大于1KB或者2KB的文件进行压缩。  

### 代理缓存
使用代理服务器的时候，存在一个问题，例如第一个客户端访问代理服务器的时候，代理服务器缓存了一份gzip的缓存；第二个客户端访问代理服务器的时候，代理服务器将gzip的缓存发送给了客户端，但是这个客户端不支持gzip压缩。  

解决方式是，web服务器在响应中添加Vary的响应头，通知代理服务器根据一个或者多个请求头来改变缓存的响应。  
```
//这样代理服务器会根据Accept-Encoding的值来缓存多份数据
Vary: Accept-Encoding
```

## 规则5：将样式表放在顶部
如果样式表仍然在加载，构建呈现树就是一种浪费，否则就会遇到FOUC(无样式内容闪烁，Flash of Unstyled Content)。

样式表放到底部，可能会导致(取决于浏览器的实现原理)：
1.白屏，浏览器需要等待所有组件下载后再呈现。
2.FOUC，先显示无样式的内容，等样式加载完毕后，重新绘制内容。

## 规则6：将脚本放在底部
### 使用脚本的问题
使用脚本时，位于脚本以下的内容，并行下载和逐步呈现都被阻塞。  

### 并行下载
HTTP1.1规范中建议浏览器从每个主机名并行地下载两个组件。

### 脚本阻塞下载
在下载脚本时，并行下载时被禁用的。

### 将脚本放到底部
脚本对web页面的影响：  
1.脚本会阻塞对其后面内容的呈现。  
2.脚本会阻塞对其后面组件的下载。  

## 规则7：避免使用CSS表达式
```
background-color: expression((new Date()).getHours() % 2 ? "#B8D4FF" : "#F08A00");
```

expression方法接收一个javascript表达式，只在IE浏览器中有效，其他浏览器会忽略该表达式。

### 更新表达式
表达式的问题是其求值的频率非常高，比如页面滚动、鼠标滑动都有可能触发表达式的计算。

有两种方式可以避免表达式频繁求值：  
1.一次性表达式  
2.事件处理器

### 一次性表达式
```
<style>
p{
  background-color: expression(altBgcolor(this));
}
</style>
<script>
  //通过将backgroundColor设置为具体的值，移除了css表达式
  function altBgcolor(elem){
	elem.backgroundColor = (new Date()).getHours() % 2 ? "#B8D4FF" : "#F08A00";
  }
</script>
```

### 事件处理器
监听事件，在事件的处理函数中更新样式。  

## 规则8：使用外部的javascript和css
内联的优势：减少http请求的数量。  
外联的优势：可以换成javascript和css，第二次访问的时候可以直接使用缓存，而不用重新请求。  

### 两全其美的方法
有两项技术可以既获得内联优势，同时也能缓存外部文件。  

1.加载后下载  
页面使用内联的方式，页面加载完成后动态下载外部组件供后续页面使用。  
```
<script>
  window.onload = function(){
    downloadJs();
    downloadCss();
  }

  function downloadJs(){
    var ele = document.createElement("script");
    ele.src = url;
    document.body.appendChild(ele);
  }

  function downloadCss(){
    var ele = document.createElement("link");
    ele.rel = "stylesheet";
    ele.href = url;
    document.body.appendChild(ele);
  }
</script>
```

2.动态内联  
如果cookie不存在，那么使用内联，如果cookie存在，那么使用外联。 

## 规则9：减少DNS查找
DNS将主机名映射到IP地址上。  
通常浏览器查找一个给定主机名称的IP地址需要花费20-120毫秒。  

### DNS缓存和TTL
DNS查找可以被缓存起来以提高性能。  

用户请求一个主机名之后，DNS信息会留在操作系统的DNS缓存中（window上的DNS Client服务）。之后对该主机名的请求无需进行过多的DNS查找。浏览器也会有自己的缓存，和操作系统的缓存是分开的。  

### 影响DNS缓存的因素
查找返回的DNS记录包含了一个存活时间（Time-to-live TTL），告诉客户端可以对该记录缓存多久。  

操作系统的缓存会考虑TTL，但浏览器通常会忽略该值，并设置它自己的时间限制。  
HTTP协议中的Keep-Alive可以同时覆盖TTL和浏览器的时间限制，只要浏览器和服务器保持着TCP连接，那么就不会进行DNS查找。  

### 减少DNS查找
减少主机名的数量会潜在地减少页面中并行下载的数量，这样可能会增加响应时间。  
在并行下载和减少主机名之间需要有一个权衡。  
使用Keep-Alive可以减少DNS的查找。

## 规则10：精简JavaScript
### 精简
精简(Minification)是从代码中移除不必要的字符以减小其大小，进而改善加载时间的实践。代码精简后所有的注释和不必要的空白都将会被移除。

### 混淆
和精简一样，它可以移除注释和空白，但是它还会将函数名、变量名改写为更短的字符串，使代码更加精炼，但是也更加难以阅读。  

混淆的缺点：  
1.缺陷，混淆过程中可能引入错误  
2.维护，对不能修改的字符需要进行标记，不能进行修改  
3.调试，代码难以阅读

**精简vs混淆**  
精简不会有混淆所带来的问题，并且实际情况中，精简和混淆的所带来的性能提升是差不多的。  

### 压缩和精简
使用gzip压缩对性能的影响最大，精简能够进一步减小文件的大小。

### 精简CSS

## 规则11：避免重定向
重定向最常见的状态码：  
1. 301，永久性转移
2. 302，暂时性转移

重定向会影响页面的性能，重定向会延迟HTML文档的传输，在HTML文档下载之前，页面中不会呈现任何东西。

URL劫持，指浏览器中显示的是A URL地址，但是内容显示的是B URL的内容，原因是A通过重定向到了B。

重定向的好处：  
1. 连接网站
2. 跟踪内部流量，每个http请求中都包含一个url（请求头中的Referer）,表明是从哪个页面发起的请求
3. 跟踪出站流量
4. 美化URL

## 规则12：删除重复脚本
重复脚本的影响：  
1. 不必要的HTTP的请求。  
2. 执行JavaScript所浪费的时间。  

## 规则13：配置ETag
### ETag是什么
实体标签(Entity Tag，Etag)是web服务器和浏览器用于确认缓存组件有效性的一种机制。ETag在Http1.1中引进，是唯一标识一个组件的一个特定版本的字符串。  

### ETag带来的问题
ETag的问题是，通常使用组件的某些属性来构造它，这些属性对于特定的、寄宿了网站的服务器来说是唯一的。但是在服务器集群中，同一个文件在不同服务器上的ETag可能是不一样的，这样会导致客户端不能够命中缓存的组件。  

If-None-Match比If-Modified-Since有更高的优先级，并且如果两者同时出现，只有这两个头都匹配上了，服务器才会返回304的响应。  

### ETag用还是不用
如果你的组件需要通过最新修改时间以外的一些东西来进行验证，那么可以使用ETag，否则使用Last-Modified更合适。  

## 规则14：使Ajax可缓存
web2.0有两个重要特性：  
1. DHTML
2. Ajax

Ajax的应用场景：  
1. 异步加载，页面的内容可以分批加载。
2. 局部更新，使得页面局部更新而不会导致页面的刷新。

Ajax通常有两种请求，POST和GET，POST请求是不可以在客户端缓存的；GET请求是可以在客户端缓存的。
